Updated step plan (optimized for scoring)

Phase A: Define and lock the project scope + docs (score: README, architecture, AI workflow)
	1.	Write the Problem description README (what it does, user stories, scope boundaries, non-goals).
	2.	Write Architecture overview (frontend, backend FastAPI, DB, storage, parsing pipeline, report pipeline).
	3.	Add AGENTS.md (how you used AI tools, prompts, workflow).
	4.	Add MCP section (even a simple MCP server usage counts if you document it properly).

Phase B: API contract first (score: OpenAPI)
	5.	Create OpenAPI spec in openapi.yaml (or generated by FastAPI but keep it stable and reviewed).
	6.	Generate a typed client for frontend from OpenAPI (or at least enforce contract-driven development).

Phase C: Backend foundation with FastAPI + DB (score: backend, database)
	7.	Scaffold FastAPI app with proper structure and dependency injection.
	8.	Add DB models + migrations (Alembic).
	9.	Implement auth: email+password + guest mode + workspace scoping.
	10.	Implement import workflow API (upload → parse job → commit).
	11.	Implement spectra retrieval endpoints for viewers.
	12.	Implement report endpoints (create report, add/remove items, export PDF).

Phase D: Frontend integration (score: frontend structure, centralized API)
	13.	Refactor frontend to use a centralized apiClient generated from OpenAPI.
	14.	Implement screens: Welcome/Auth, Dashboard/Samples, Import status, Sample workspace, Reports.
	15.	Wire plotting and report selection to backend state.

Phase E: Tests (score: unit + integration)
	16.	Unit tests:

	•	parsing helpers (zip parsing, DSC/DTA type inference, filename tokens, time axis normalization)
	•	report selection state logic

	17.	Integration tests (separate folder):

	•	auth + guest workspace
	•	upload import zip → parse → samples created
	•	fetch sample → spectra list → spectrum data
	•	create report → add items → export artifact

Phase F: Containerize + deploy + CI/CD (score: containerization, deployment, CI/CD, reproducibility)
	18.	Dockerize:

	•	apps/api/Dockerfile
	•	apps/web/Dockerfile
	•	docker-compose.yml for: api, web, postgres, (optional) redis, object storage (minio)

	19.	Deployment:

	•	choose one cloud target that’s easy to prove (Render/Fly.io for FastAPI, Vercel/Netlify for frontend, managed Postgres)
	•	publish URL(s) and include in README

	20.	CI/CD:

	•	GitHub Actions: lint + unit tests + integration tests (with docker-compose)
	•	deploy step triggered on main after tests pass